from firebase_functions import https_fn, options
from firebase_admin import initialize_app, storage
from gradio_client import Client, handle_file
import time
import json
import requests
import httpx
import tempfile
import os
import traceback
from functools import wraps
import subprocess

###############################################################################
# Cloud Functions Settings
###############################################################################
# Increase timeout to 540 seconds (9 minutes) and memory to 4GB
options.set_global_options(
    region="us-central1",
    memory=4096,  # 4 GiB
    timeout_sec=540  # 9 minutes
)

# Initialize Firebase Admin
app = initialize_app(options={
    'storageBucket': 'taiyaki-test1.firebasestorage.app'
})

###############################################################################
# The "Original" Advanced Blender Script
###############################################################################
# We use __GLB_PATH__ and __STL_PATH__ placeholders that we'll replace at runtime.
# This script:
#  - Imports a GLB
#  - Joins multiple meshes
#  - Removes doubles, triangulates, recalculates normals
#  - Validates geometry
#  - Manually writes the STL in binary format (like your old code)

BLENDER_SCRIPT = r'''
import bpy
import sys
import os
import struct
import math
from mathutils import Vector

def validate_mesh(obj):
    """Validate mesh data and print warnings."""
    mesh = obj.data
    issues = []
    
    # Check for zero-area faces
    for face in mesh.polygons:
        if face.area < 1e-7:  # threshold for near-zero area
            issues.append("Warning: Face {} has near-zero area".format(face.index))
    
    # Check for non-manifold edges
    bpy.ops.object.mode_set(mode='EDIT')
    bpy.ops.mesh.select_all(action='DESELECT')
    bpy.ops.mesh.select_non_manifold()
    bpy.ops.object.mode_set(mode='OBJECT')
    
    non_manifold_verts = [v for v in mesh.vertices if v.select]
    if non_manifold_verts:
        issues.append("Warning: Found {} non-manifold vertices".format(len(non_manifold_verts)))
    
    return issues

def write_stl(filepath, ob):
    """Write STL data for the given object in binary format."""
    mesh = ob.data
    face_count = len(mesh.polygons)
    print(f"Writing {face_count} faces to STL file at {filepath}")
    
    matrix = ob.matrix_world
    
    with open(filepath, 'wb') as fp:
        # 80-byte header
        header = b'Binary STL generated by Blender advanced script'
        header = header + (80 - len(header)) * b'\0'
        fp.write(header)
        
        # Number of faces (unsigned int)
        fp.write(struct.pack('<I', face_count))
        
        vertex_count = 0
        
        for face in mesh.polygons:
            # Transform normal to world space
            normal = matrix.to_3x3() @ face.normal
            normal.normalize()
            if math.isnan(normal.x) or math.isnan(normal.y) or math.isnan(normal.z):
                normal = Vector((0, 0, 1))
            
            # Write normal
            fp.write(struct.pack('<3f', float(normal.x), float(normal.y), float(normal.z)))
            
            # Write vertices
            for vert_idx in face.vertices:
                vert = matrix @ mesh.vertices[vert_idx].co
                fp.write(struct.pack('<3f', float(vert.x), float(vert.y), float(vert.z)))
                vertex_count += 1
            
            # Attribute byte count
            fp.write(struct.pack('<H', 0))
    
    file_size = os.path.getsize(filepath)
    print(f"STL Export Stats:\n - File size: {file_size} bytes\n - Face count: {face_count}\n - Vertex count: {vertex_count}")
    return file_size

def prepare_mesh(obj):
    """Prepare mesh for export (remove doubles, triangulate, recalc normals)."""
    print("Preparing mesh for export (remove doubles, triangulate, recalc normals).")
    bpy.ops.object.mode_set(mode='EDIT')
    bpy.ops.mesh.select_all(action='SELECT')
    bpy.ops.mesh.remove_doubles(threshold=0.0001)
    bpy.ops.mesh.quads_convert_to_tris(quad_method='BEAUTY', ngon_method='BEAUTY')
    bpy.ops.mesh.normals_make_consistent(inside=False)
    bpy.ops.object.mode_set(mode='OBJECT')

def advanced_convert_glb_to_stl():
    """
    This function references __GLB_PATH__ and __STL_PATH__,
    which we'll replace at runtime in Python.
    """
    input_path = "__GLB_PATH__"
    output_path = "__STL_PATH__"
    
    print(f"\nConverting {input_path} to {output_path} with advanced script.")
    
    # Clear default
    bpy.ops.object.select_all(action='SELECT')
    bpy.ops.object.delete()
    
    # Import the GLB
    print("Importing GLB...")
    result = bpy.ops.import_scene.gltf(filepath=input_path)
    if result != {'FINISHED'}:
        raise Exception(f"GLB import failed with result: {result}")
    
    # Debug: print imported objects
    print("\nScene objects after import:")
    for obj in bpy.context.scene.objects:
        print(f" - {obj.name} (Type: {obj.type})")
    
    # Find all MESH objects
    mesh_objects = [o for o in bpy.context.scene.objects if o.type == 'MESH']
    print(f"Found {len(mesh_objects)} mesh objects.")
    if not mesh_objects:
        raise Exception("No mesh objects found in GLB.")

    # If multiple, join them
    bpy.ops.object.select_all(action='DESELECT')
    for obj in mesh_objects:
        obj.select_set(True)
    bpy.context.view_layer.objects.active = mesh_objects[0]
    
    if len(mesh_objects) > 1:
        print(f"Joining {len(mesh_objects)} mesh objects into one.")
        bpy.ops.object.join()
    
    mesh_obj = bpy.context.active_object
    if not mesh_obj or mesh_obj.type != 'MESH':
        raise Exception("No active mesh object after joining or not a MESH type.")
    
    print(f"Active mesh: {mesh_obj.name} - {len(mesh_obj.data.vertices)} verts, {len(mesh_obj.data.polygons)} faces.")
    
    # Prepare geometry
    prepare_mesh(mesh_obj)
    
    # Validate
    issues = validate_mesh(mesh_obj)
    for issue in issues:
        print(issue)

    # Apply transforms
    bpy.ops.object.transform_apply(location=True, rotation=True, scale=True)
    
    # Write out the STL
    file_size = write_stl(output_path, mesh_obj)
    if file_size == 0:
        raise Exception("STL file is empty.")
    print("Advanced conversion completed successfully!")

# Actually run the function
advanced_convert_glb_to_stl()
'''

###############################################################################
# Exponential Retry Decorator
###############################################################################
def retry_operation(max_retries=3, initial_delay=5):
    def decorator(operation):
        @wraps(operation)
        def wrapper(*args, **kwargs):
            last_exception = None
            delay = initial_delay
            for attempt in range(max_retries):
                try:
                    print(f"Attempt {attempt + 1} of {max_retries} for {operation.__name__}")
                    return operation(*args, **kwargs)
                except (httpx.ReadTimeout, httpx.ConnectTimeout) as e:
                    last_exception = e
                    print(f"Timeout on attempt {attempt + 1}: {str(e)}")
                    print(f"Error traceback: {traceback.format_exc()}")
                except Exception as e:
                    last_exception = e
                    print(f"Error on attempt {attempt + 1}: {str(e)}")
                    print(f"Error traceback: {traceback.format_exc()}")
                
                if attempt < max_retries - 1:
                    sleep_time = delay * (2 ** attempt)
                    print(f"Waiting {sleep_time} seconds before retry...")
                    time.sleep(sleep_time)
            print(f"All {max_retries} attempts failed for {operation.__name__}")
            raise last_exception
        return wrapper
    return decorator

###############################################################################
# Download Helper
###############################################################################
@retry_operation(max_retries=3, initial_delay=5)
def download_image(url: str, temp_path: str) -> None:
    with httpx.Client(timeout=httpx.Timeout(connect=30.0, read=180.0, write=60.0, pool=60.0)) as client:
        response = client.get(url)
        response.raise_for_status()
        with open(temp_path, 'wb') as f:
            f.write(response.content)

###############################################################################
# Upload to Firebase
###############################################################################
def upload_to_firebase(local_path, destination_path):
    try:
        bucket = storage.bucket()
        blob = bucket.blob(destination_path)
        blob.upload_from_filename(local_path)
        public_url = f"https://storage.googleapis.com/{bucket.name}/{destination_path}"
        return public_url
    except Exception as e:
        print(f"Error uploading to Firebase: {e}")
        print(f"Error traceback: {traceback.format_exc()}")
        raise

###############################################################################
# The "advanced" Blender call using .replace() approach
###############################################################################
def convert_glb_to_stl_advanced(glb_path: str, stl_path: str):
    """
    Runs Blender in headless mode, using the advanced script with
    mesh joining, removing doubles, triangulation, validations, etc.
    
    We do .replace("__GLB_PATH__", glb_path) and .replace("__STL_PATH__", stl_path)
    so we don't conflict with curly braces in the code above.
    """
    print("\n[convert_glb_to_stl_advanced] Starting advanced conversion.")
    print("Current working directory:", os.getcwd())
    print("Directory contents:", os.listdir())
    print("PATH environment:", os.environ.get('PATH'))
    
    blender_path = '/usr/local/blender-3.6.0-linux-x64/blender'
    print(f"Using Blender at: {blender_path}")

    # Make a copy of the script, replacing placeholders
    script_for_blender = BLENDER_SCRIPT \
        .replace("__GLB_PATH__", glb_path) \
        .replace("__STL_PATH__", stl_path)

    try:
        process = subprocess.run(
            [
                blender_path,
                '--background',
                '--python-expr',
                script_for_blender
            ],
            capture_output=True,
            text=True
        )
        print("Blender stdout:", process.stdout)
        print("Blender stderr:", process.stderr)

        if process.returncode != 0:
            raise Exception(f"Blender advanced script failed:\n{process.stderr}")
        
        if not os.path.exists(stl_path):
            raise Exception("STL file was not created.")
        
        file_size = os.path.getsize(stl_path)
        if file_size == 0:
            raise Exception("STL file is empty after advanced conversion.")

        print(f"[convert_glb_to_stl_advanced] Conversion success, STL size: {file_size} bytes")
        return file_size
    
    except Exception as e:
        print("Error during advanced Blender conversion:", e)
        raise

###############################################################################
# 1) The process_3d Function
###############################################################################
from gradio_client import Client, handle_file

@https_fn.on_request()
def process_3d(request: https_fn.Request) -> https_fn.Response:
    """
    Existing 'process_3d' endpoint for generating GLB, etc.
    Not directly related to the advanced script,
    but included here for completeness.
    """
    if request.method == 'OPTIONS':
        headers = {
            "Access-Control-Allow-Origin": "*",
            "Access-Control-Allow-Methods": "GET, POST",
            "Access-Control-Allow-Headers": "Content-Type",
        }
        return https_fn.Response('', status=204, headers=headers)

    headers = {"Access-Control-Allow-Origin": "*", "Content-Type": "application/json"}
    temp_files = []
    start_time = time.time()

    try:
        print(f"[process_3d] Starting at {time.time()}")
        
        # Create Gradio client
        client = Client("eleelenawa/TRELLIS")
        print(f"{time.time() - start_time:.2f}s: Created Gradio client")

        # Attempt to start Gradio session
        try:
            client.predict(api_name="/start_session")
            time.sleep(2)
            print(f"{time.time() - start_time:.2f}s: Started session")
        except Exception as e:
            print(f"[process_3d] Possibly ignoring Gradio error: {e}")

        # Request data
        request_json = request.get_json()
        print(f"Request data: {json.dumps(request_json, indent=2)}")
        
        image_url = request_json.get('image_url')
        user_id = request_json.get('userId', 'default')
        if not image_url:
            return https_fn.Response(json.dumps({"error": "No image URL"}), headers=headers, status=400)

        timestamp = int(time.time() * 1000)
        
        # 1) Download
        temp_path = os.path.join(tempfile.gettempdir(), f"temp_image_{timestamp}.png")
        temp_files.append(temp_path)
        print(f"{time.time() - start_time:.2f}s: Downloading image from {image_url} ...")
        download_image(image_url, temp_path)
        print(f"{time.time() - start_time:.2f}s: Download complete")

        # 2) Preprocess
        print(f"{time.time() - start_time:.2f}s: Preprocessing image...")
        preprocessed_result = run_preprocessing(client, temp_path)
        preprocessed_path = preprocessed_result[0] if isinstance(preprocessed_result, (list, tuple)) else preprocessed_result
        temp_files.append(preprocessed_path)

        preprocessed_url = upload_to_firebase(preprocessed_path, f"processed/{user_id}/{timestamp}/preprocessed.png")
        print(f"{time.time() - start_time:.2f}s: Preprocessing complete -> {preprocessed_url}")

        # 3) 3D generation
        print(f"{time.time() - start_time:.2f}s: Starting 3D generation...")
        three_d_result = run_3d_generation(client, temp_path)
        video_path = three_d_result['video']
        temp_files.append(video_path)

        video_url = upload_to_firebase(video_path, f"processed/{user_id}/{timestamp}/preview.mp4")
        print(f"{time.time() - start_time:.2f}s: 3D generation complete -> {video_url}")

        # 4) Extract GLB
        print(f"{time.time() - start_time:.2f}s: Extracting GLB...")
        glb_result = run_glb_extraction(client)
        
        glb_urls = []
        if isinstance(glb_result, (list, tuple)):
            for idx, one_glb in enumerate(glb_result):
                temp_files.append(one_glb)
                glb_url = upload_to_firebase(one_glb, f"processed/{user_id}/{timestamp}/model_{idx}.glb")
                glb_urls.append(glb_url)
        else:
            temp_files.append(glb_result)
            glb_url = upload_to_firebase(glb_result, f"processed/{user_id}/{timestamp}/model.glb")
            glb_urls = [glb_url]

        print(f"{time.time() - start_time:.2f}s: GLB extraction complete -> {glb_urls}")

        total_time = time.time() - start_time
        return https_fn.Response(json.dumps({
            "success": True,
            "preprocessed_url": preprocessed_url,
            "video_url": video_url,
            "glb_urls": glb_urls,
            "timestamp": timestamp,
            "userId": user_id,
            "processing_time": total_time
        }), headers=headers, status=200)

    except Exception as e:
        print(f"[process_3d] Exception: {e}")
        print(traceback.format_exc())
        return https_fn.Response(json.dumps({
            "error": str(e),
            "traceback": traceback.format_exc()
        }), headers=headers, status=500)
    finally:
        for temp_file in temp_files:
            if temp_file and os.path.exists(temp_file):
                try:
                    os.remove(temp_file)
                    print(f"[process_3d] Cleaned up: {temp_file}")
                except:
                    pass

###############################################################################
# 2) The "convert_glb_http" Function (using advanced script)
###############################################################################
@https_fn.on_request()
def convert_glb_http(request: https_fn.Request) -> https_fn.Response:
    """
    Converts a GLB to STL using the advanced script (mesh joining,
    remove doubles, triangulation, etc.) by substituting __GLB_PATH__ / __STL_PATH__.
    """
    if request.method == 'OPTIONS':
        headers = {
            "Access-Control-Allow-Origin": "*",
            "Access-Control-Allow-Methods": "GET, POST",
            "Access-Control-Allow-Headers": "Content-Type",
        }
        return https_fn.Response('', status=204, headers=headers)

    headers = {
        "Access-Control-Allow-Origin": "*",
        "Content-Type": "application/json"
    }
    temp_files = []
    start_time = time.time()

    try:
        request_json = request.get_json()
        print(f"[convert_glb_http] Request data: {json.dumps(request_json, indent=2)}")

        glb_url = request_json.get('glbUrl')
        design_id = request_json.get('designId')
        if not glb_url or not design_id:
            return https_fn.Response(json.dumps({"error": "Missing glbUrl or designId"}), headers=headers, status=400)

        print(f"[convert_glb_http] Starting advanced GLBâ†’STL conversion for {glb_url}, ID: {design_id}")

        with tempfile.TemporaryDirectory() as temp_dir:
            glb_path = os.path.join(temp_dir, f"{design_id}.glb")
            stl_path = os.path.join(temp_dir, f"{design_id}.stl")
            temp_files.extend([glb_path, stl_path])

            # 1) Download the GLB
            print(f"{time.time() - start_time:.2f}s: Downloading GLB...")
            download_image(glb_url, glb_path)
            print(f"{time.time() - start_time:.2f}s: GLB downloaded -> {os.path.getsize(glb_path)} bytes")

            # 2) Convert with advanced script
            print(f"{time.time() - start_time:.2f}s: Running advanced conversion...")
            file_size = convert_glb_to_stl_advanced(glb_path, stl_path)
            print(f"{time.time() - start_time:.2f}s: Conversion done, STL size = {file_size} bytes")

            # 3) Upload STL
            print(f"{time.time() - start_time:.2f}s: Uploading STL to Firebase...")
            stl_url = upload_to_firebase(stl_path, f"conversions/{design_id}/{design_id}.stl")
            print(f"{time.time() - start_time:.2f}s: Upload complete -> {stl_url}")

            total_time = time.time() - start_time
            return https_fn.Response(json.dumps({
                "success": True,
                "stlUrl": stl_url,
                "designId": design_id,
                "processing_time": total_time
            }), headers=headers, status=200)

    except Exception as e:
        err_time = time.time() - start_time
        print(f"[convert_glb_http] ERROR at {err_time:.2f}s: {e}")
        print(traceback.format_exc())
        return https_fn.Response(json.dumps({
            "error": str(e),
            "traceback": traceback.format_exc()
        }), headers=headers, status=500)
    finally:
        for temp_file in temp_files:
            if temp_file and os.path.exists(temp_file):
                try:
                    os.remove(temp_file)
                    print(f"[convert_glb_http] Cleaned up: {temp_file}")
                except:
                    pass