# import bpy
# import sys
# import os
# import struct
# import math
# from mathutils import Vector

# def validate_mesh(obj):
#     """Validate mesh data and print warnings"""
#     mesh = obj.data
#     issues = []
    
#     # Check for zero-area faces
#     for face in mesh.polygons:
#         if face.area < 1e-7:  # Small threshold for zero area
#             issues.append(f"Warning: Face {face.index} has near-zero area")
    
#     # Check for non-manifold edges
#     bpy.ops.object.mode_set(mode='EDIT')
#     bpy.ops.mesh.select_all(action='DESELECT')
#     bpy.ops.mesh.select_non_manifold()
#     bpy.ops.object.mode_set(mode='OBJECT')
    
#     non_manifold_verts = [v for v in mesh.vertices if v.select]
#     if non_manifold_verts:
#         issues.append(f"Warning: Found {len(non_manifold_verts)} non-manifold vertices")
    
#     return issues

# def write_stl(filepath, ob):
#     """Write STL data for the given object"""
#     mesh = ob.data
#     face_count = len(mesh.polygons)
#     print(f"Writing {face_count} faces to STL file")
    
#     # Get world matrix for transformations
#     matrix = ob.matrix_world
    
#     with open(filepath, 'wb') as fp:
#         # Write STL header (80 bytes)
#         header = b'Binary STL generated by Blender'
#         header = header + (80-len(header)) * b'\0'
#         fp.write(header)
        
#         # Write number of faces
#         fp.write(struct.pack('<I', face_count))
        
#         # Track vertices for debugging
#         vertex_count = 0
        
#         # Iterate over faces and write data
#         for face in mesh.polygons:
#             try:
#                 # Transform normal to world space
#                 normal = matrix.to_3x3() @ face.normal
#                 normal.normalize()
                
#                 # Ensure normal is valid (handle degenerate cases)
#                 if math.isnan(normal.x) or math.isnan(normal.y) or math.isnan(normal.z):
#                     normal = Vector((0, 0, 1))
                
#                 # Write normal
#                 fp.write(struct.pack('<3f', 
#                     float(normal.x),
#                     float(normal.y),
#                     float(normal.z)
#                 ))
                
#                 # Write vertices
#                 for vert_idx in face.vertices:
#                     # Transform vertex to world space
#                     vert = matrix @ mesh.vertices[vert_idx].co
#                     fp.write(struct.pack('<3f',
#                         float(vert.x),
#                         float(vert.y),
#                         float(vert.z)
#                     ))
#                     vertex_count += 1
                
#                 # Attribute byte count (unused)
#                 fp.write(struct.pack('<H', 0))
                
#             except Exception as e:
#                 print(f"Warning: Error writing face {face.index}: {str(e)}")
#                 continue
    
#     # Get file size and report statistics
#     file_size = os.path.getsize(filepath)
#     print(f"\nSTL Statistics:")
#     print(f"- File size: {file_size:,} bytes")
#     print(f"- Face count: {face_count:,}")
#     print(f"- Vertex count: {vertex_count:,}")
    
#     # Verify file size
#     expected_size = 84 + (50 * face_count)  # Header + face count + (normal + 3 vertices + attribute) * face_count
#     if file_size != expected_size:
#         print(f"Warning: File size mismatch. Expected {expected_size:,} bytes, got {file_size:,} bytes")
    
#     return file_size

# def prepare_mesh(obj):
#     """Prepare mesh for STL export"""
#     print("\nPreparing mesh for export...")
    
#     # Enter edit mode
#     bpy.ops.object.mode_set(mode='EDIT')
    
#     # Select all geometry
#     bpy.ops.mesh.select_all(action='SELECT')
    
#     # Remove doubles (duplicate vertices)
#     bpy.ops.mesh.remove_doubles(threshold=0.0001)
    
#     # Triangulate
#     bpy.ops.mesh.quads_convert_to_tris(quad_method='BEAUTY', ngon_method='BEAUTY')
    
#     # Recalculate normals
#     bpy.ops.mesh.normals_make_consistent(inside=False)
    
#     # Return to object mode
#     bpy.ops.object.mode_set(mode='OBJECT')
    
#     print("Mesh preparation completed")

# def convert_glb_to_stl(input_path, output_path):
#     print(f"Converting {input_path} to {output_path}")
#     print(f"Current working directory: {os.getcwd()}")
    
#     try:
#         # Clear existing objects
#         bpy.ops.object.select_all(action='SELECT')
#         bpy.ops.object.delete()
        
#         # Import GLB
#         print("\nImporting GLB file...")
#         result = bpy.ops.import_scene.gltf(filepath=input_path)
#         if result != {'FINISHED'}:
#             raise Exception(f"GLB import failed with result: {result}")
        
#         # Print scene information
#         print("\nScene objects after import:")
#         for obj in bpy.context.scene.objects:
#             print(f"- {obj.name} (Type: {obj.type})")
        
#         # Get all mesh objects
#         mesh_objects = [obj for obj in bpy.context.scene.objects if obj.type == 'MESH']
#         print(f"\nFound {len(mesh_objects)} mesh objects")
        
#         if not mesh_objects:
#             raise Exception("No mesh objects found in GLB file")
        
#         # Select all mesh objects
#         bpy.ops.object.select_all(action='DESELECT')
#         for obj in mesh_objects:
#             obj.select_set(True)
#             print(f"Selected mesh: {obj.name}")
#             print(f"- Vertices: {len(obj.data.vertices):,}")
#             print(f"- Faces: {len(obj.data.polygons):,}")
        
#         # Set active object
#         bpy.context.view_layer.objects.active = mesh_objects[0]
        
#         # Join objects if multiple
#         if len(mesh_objects) > 1:
#             print(f"\nJoining {len(mesh_objects)} mesh objects")
#             bpy.ops.object.join()
        
#         # Get final mesh object
#         mesh_obj = bpy.context.active_object
#         if not mesh_obj:
#             raise Exception("No active mesh object after processing")
        
#         print(f"\nFinal mesh: {mesh_obj.name}")
#         print(f"- Vertices: {len(mesh_obj.data.vertices):,}")
#         print(f"- Faces: {len(mesh_obj.data.polygons):,}")
        
#         # Prepare mesh
#         prepare_mesh(mesh_obj)
        
#         # Validate mesh
#         issues = validate_mesh(mesh_obj)
#         for issue in issues:
#             print(issue)
        
#         # Apply transformations
#         bpy.ops.object.transform_apply(location=True, rotation=True, scale=True)
        
#         # Write STL file
#         print("\nWriting STL file...")
#         file_size = write_stl(output_path, mesh_obj)
        
#         if not os.path.exists(output_path):
#             raise Exception("STL file was not created")
        
#         if file_size == 0:
#             raise Exception("STL file is empty")
            
#         print(f"\nConversion completed successfully")
#         print(f"STL file created: {output_path}")
#         print(f"File size: {file_size:,} bytes")
        
#     except Exception as e:
#         print(f"\nError during conversion: {str(e)}")
#         raise

# if __name__ == "__main__":
#     if len(sys.argv) < 4:
#         print("Usage: blender --background --python script.py -- input.glb output.stl")
#         sys.exit(1)
    
#     input_file = sys.argv[-2]
#     output_file = sys.argv[-1]
    
#     try:
#         convert_glb_to_stl(input_file, output_file)
#     except Exception as e:
#         print(f"Conversion failed: {str(e)}")
#         sys.exit(1)